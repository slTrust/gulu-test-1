### input组件

input.vue

```
<template>
    <div>
        <input type="text">
    </div>
</template>

<script>
    export default {
        name: "gulu-input"
    }
</script>

<style scoped>

</style>
```

全局注册

```
import Input from './input';
Vue.component('g-input',Input);
```

使用 input组件

```
<g-input/>
这样引入会报错
```

> #### 为什么自闭和不行呢？

因为vue的文档说的很清楚，vue的模版使用的是 html语法，而没说它是 xml语法


```
所以 如果是 xml 你可以<g-input/> 它允许自闭和

但是 html呢？

html语法 规定自定义标签不允许自闭和
所以你应该老老实实的写成

<g-input></g-input>
```

#### 单文件组件里 name属性的作用

- 请先安装 vue-devtools

这个name是用来调试的，方便你定位你的组件，如果你不起名它就是GInput


#### 单文件组件里 scoped的作用

- 样式的隔离，避免组件之间的冲突 - 推荐每个组件都使用它

```
<style scoped></style>
```

#### webstorm 折叠css的设置


```
shift shift 
搜索 join line
```

#### 添加 change事件

- 输入的时候不会改变 失去焦点的时候才触发

> 目标change触发的时候打印对应的输入框文本

```
input.vue里
<input :value="value" type="text" :disabled="disabled" :readonly="readonly"
    @change="$emit('change',$event,'hi')"
>

index.html里
<g-input value="赵" @change="inputChange"></g-input>

app.js里
methods:{
    inputChange(e,yyyy){
        console.log(e.target.value);
        console.log(yyyy);
    }
}

这样我们就知道$emit('change',$event,'hi') 详细的参数
第一个是事件名
第二个是传递给事件接受者的第一个参数 (事件源，当前输入框)
第三个是传递给事件接受者的第二个参数 
```

其余事件 依次类推

- input
- focus
- blur

#### 测试用例

test/input.test.js

```
const expect = chai.expect;
import Vue from 'vue'
import Input from '../src/input'

Vue.config.productionTip = false
Vue.config.devtools = false

describe('Input', () => {
    it('存在.', () => {
        expect(Input).to.exist
    })

    // 可以嵌套  describe 来实现 分组
    describe('接受 props',()=>{
        it('接受 value', () => {
            const Constructor = Vue.extend(Input)
            const vm = new Constructor({
                propsData: {
                    value: '1234'
                }
            }).$mount()
            const inputElement = vm.$el.querySelector('input')
            expect(inputElement.value).to.equal('1234')
            vm.$destroy()
        })

        it('接受 disabled', () => {
            const Constructor = Vue.extend(Input)
            const vm = new Constructor({
                propsData: {
                    disabled: true
                }
            }).$mount()
            const inputElement = vm.$el.querySelector('input')
            expect(inputElement.disabled).to.equal(true)
            vm.$destroy()
        })

        it('接受 readonly', () => {
            const Constructor = Vue.extend(Input)
            const vm = new Constructor({
                propsData: {
                    readonly: true
                }
            }).$mount()
            const inputElement = vm.$el.querySelector('input')
            // 注意此时 readonly 竟然是 驼峰标识
            expect(inputElement.readOnly).to.equal(true)
            vm.$destroy()
        })

        it('接受 error', () => {
            const Constructor = Vue.extend(Input)
            const vm = new Constructor({
                propsData: {
                    error: '你错了'
                }
            }).$mount()

            const iconElement = vm.$el.querySelector('use')
            expect(iconElement.getAttribute('xlink:href')).to.equal('#i-error')

            const errorElement = vm.$el.querySelector('.errorMessage')
            expect(errorElement.innerText).to.equal('你错了')
            vm.$destroy()
        })
    })

    describe('事件',()=>{
        
    })

})
```

- describe可以嵌套 这样就可以分组的测试

> 现在有一个问题：重复代码很多

```
const Constructor = Vue.extend(Input)
const vm = new Constructor().$mount()
vm.$destroy()
```

> #### 看文档  mochajs.org

[https://mochajs.org/](https://mochajs.org/)

HOOK 里 的 before/after/beforeEach/afterEach
